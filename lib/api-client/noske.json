{
	"openapi": "3.0.3",
	"info": {
		"title": "NoSketch Engine RestAPI",
		"description": "An open-source project combining Manatee and Bonito and Crystal into a powerful and free corpus management system. NoSketch Engine is a limited version of the software empowering the famous Sketch Engine service",
		"version": "0.0.1b"
	},
	"servers": [
		{
			"url": "https://noskecrystal5corpsum.acdh-dev.oeaw.ac.at/run.cgi"
		}
	],
	"paths": {
		"/corpora": {
			"get": {
				"tags": [
					"Corpora"
				],
				"summary": "Returns a list of all corpora accessible to you.",
				"responses": {
					"200": {
						"description": "`OK`",
						"content": {
							"application/json": {
								"schema": {
									"type": "object",
									"properties": {
										"data": {
											"type": "array",
											"items": {
												"$ref": "#/components/schemas/03_corpora_list"
											}
										}
									}
								}
							}
						}
					}
				}
			}
		},
		"/corp_info": {
			"get": {
				"parameters": [
					{
						"$ref": "#/components/parameters/001_corpname"
					},
					{
						"$ref": "#/components/parameters/002_usesubcorp"
					},
					{
						"$ref": "#/components/parameters/006_subcorpora"
					},
					{
						"$ref": "#/components/parameters/003_gramrels"
					},
					{
						"$ref": "#/components/parameters/004_corpcheck"
					},
					{
						"$ref": "#/components/parameters/005_registry"
					},
					{
						"$ref": "#/components/parameters/007_struct_attr_stats"
					},
					{
						"$ref": "#/components/parameters/008_format"
					}
				],
				"tags": [
					"Corpus Search"
				],
				"summary": "Statistics and information about the whole corpus.",
				"responses": {
					"200": {
						"description": "`OK`",
						"content": {
							"application/json": {
								"schema": {
									"$ref": "#/components/schemas/01_corp_info"
								}
							}
						}
					}
				}
			}
		},
		"/subcorp": {
			"get": {
				"parameters": [
					{
						"$ref": "#/components/parameters/001_corpname"
					},
					{
						"$ref": "#/components/parameters/054_subcname"
					},
					{
						"$ref": "#/components/parameters/155_create"
					},
					{
						"$ref": "#/components/parameters/055_delete"
					},
					{
						"$ref": "#/components/parameters/156_q_subcorp"
					},
					{
						"$ref": "#/components/parameters/157_struct"
					},
					{
						"$ref": "#/components/parameters/160_json_subcorp"
					},
					{
						"$ref": "#/components/parameters/008_format"
					}
				],
				"tags": [
					"Corpus Search"
				],
				"summary": "Get a list of subcorpora in the corpus or create/delete a subcorpus.",
				"description": "There is two option how to create subcorpora in Sketch Engine from `text types` => json parameter (corpus must be annotated for text types) or from `concordances` => q + struct parameters.",
				"responses": {
					"200": {
						"description": "`OK`",
						"content": {
							"application/json": {
								"schema": {
									"$ref": "#/components/schemas/07_subcorp"
								}
							}
						}
					}
				}
			}
		},
		"/freqml": {
			"get": {
				"tags": [
					"Corpus Search"
				],
				"summary": "Calculates frequencies of words, lemmas… in the concordance.",
				"description": "The frequency of any [positional attribute] (https://www.sketchengine.eu/my_keywords/positional-attribute/) such as word forms, lemmas, tags can be counted with this method. Structure attributes (metadata/text types) can also be counted.",
				"parameters": [
					{
						"$ref": "#/components/parameters/001_corpname"
					},
					{
						"$ref": "#/components/parameters/100_ml1attr"
					},
					{
						"$ref": "#/components/parameters/101_ml1ctx"
					},
					{
						"$ref": "#/components/parameters/141_ml2attr"
					},
					{
						"$ref": "#/components/parameters/142_ml2ctx"
					},
					{
						"$ref": "#/components/parameters/143_ml3attr"
					},
					{
						"$ref": "#/components/parameters/144_ml3ctx"
					},
					{
						"$ref": "#/components/parameters/145_ml4attr"
					},
					{
						"$ref": "#/components/parameters/146_ml4ctx"
					},
					{
						"$ref": "#/components/parameters/147_ml5attr"
					},
					{
						"$ref": "#/components/parameters/148_ml5ctx"
					},
					{
						"$ref": "#/components/parameters/149_ml6attr"
					},
					{
						"$ref": "#/components/parameters/150_ml6ctx"
					},
					{
						"$ref": "#/components/parameters/041_q"
					},
					{
						"$ref": "#/components/parameters/002_usesubcorp"
					},
					{
						"$ref": "#/components/parameters/044_fmaxitems"
					},
					{
						"$ref": "#/components/parameters/094_fpage"
					},
					{
						"$ref": "#/components/parameters/095_group"
					},
					{
						"$ref": "#/components/parameters/096_showpoc"
					},
					{
						"$ref": "#/components/parameters/097_showreltt"
					},
					{
						"$ref": "#/components/parameters/098_showrel"
					},
					{
						"$ref": "#/components/parameters/099_freqlevel"
					},
					{
						"$ref": "#/components/parameters/040_json"
					},
					{
						"$ref": "#/components/parameters/045_freq_sort"
					},
					{
						"$ref": "#/components/parameters/008_format"
					}
				],
				"responses": {
					"200": {
						"description": "`OK`",
						"content": {
							"application/json": {
								"schema": {
									"$ref": "#/components/schemas/11_freqml"
								}
							}
						}
					}
				}
			}
		},
		"/concordance": {
			"get": {
				"parameters": [
					{
						"$ref": "#/components/parameters/001_corpname"
					},
					{
						"$ref": "#/components/parameters/041_q"
					},
					{
						"$ref": "#/components/parameters/127_concordance_query_queryselector"
					},
					{
						"$ref": "#/components/parameters/128_concordance_query_iquery"
					},
					{
						"$ref": "#/components/parameters/129_concordance_query_cql"
					},
					{
						"$ref": "#/components/parameters/130_concordance_query_lemma"
					},
					{
						"$ref": "#/components/parameters/131_concordance_query_char"
					},
					{
						"$ref": "#/components/parameters/132_concordance_query_word"
					},
					{
						"$ref": "#/components/parameters/133_concordance_query_phrase"
					},
					{
						"$ref": "#/components/parameters/002_usesubcorp"
					},
					{
						"$ref": "#/components/parameters/025_lpos"
					},
					{
						"$ref": "#/components/parameters/077_default_attr"
					},
					{
						"$ref": "#/components/parameters/058_attrs"
					},
					{
						"$ref": "#/components/parameters/078_refs"
					},
					{
						"$ref": "#/components/parameters/079_attr_allpos"
					},
					{
						"$ref": "#/components/parameters/080_viewmode"
					},
					{
						"$ref": "#/components/parameters/081_cup_hl"
					},
					{
						"$ref": "#/components/parameters/082_structs"
					},
					{
						"$ref": "#/components/parameters/083_fromp"
					},
					{
						"$ref": "#/components/parameters/084_pagesize"
					},
					{
						"$ref": "#/components/parameters/085_kwicleftctx"
					},
					{
						"$ref": "#/components/parameters/086_kwicrightctx"
					},
					{
						"$ref": "#/components/parameters/134_errcorr_switch"
					},
					{
						"$ref": "#/components/parameters/135_cup_err_code"
					},
					{
						"$ref": "#/components/parameters/136_cup_err"
					},
					{
						"$ref": "#/components/parameters/137_cup_corr"
					},
					{
						"$ref": "#/components/parameters/040_json"
					},
					{
						"$ref": "#/components/parameters/039_asyn"
					},
					{
						"$ref": "#/components/parameters/008_format"
					}
				],
				"tags": [
					"Corpus Search"
				],
				"summary": "Concordance - shows the search word or phrase in context.",
				"description": "The concordance allows complex criteria for searching the corpus. The queries can combine any data, metadata and annotations found in the corpus.\n\n `To make basic concordance its enough to use just corpname and q parameters.`",
				"responses": {
					"200": {
						"description": "`OK`",
						"content": {
							"application/json": {
								"schema": {
									"$ref": "#/components/schemas/06_concordance"
								}
							}
						}
					}
				}
			}
		}
	},
	"components": {
		"securitySchemes": {
			"basicAuth": {
				"type": "http",
				"scheme": "basic"
			}
		},
		"parameters": {
			"001_corpname": {
				"in": "query",
				"name": "corpname",
				"schema": {
					"type": "string"
				},
				"required": true,
				"description": "Corpus name. To query your own corpus (e.g. username john, corpus mycorpus), `use` value `user/john/mycorpus`.",
				"example": "preloaded/bnc2_tt21"
			},
			"002_usesubcorp": {
				"in": "query",
				"name": "usesubcorp",
				"schema": {
					"type": "string"
				},
				"description": "The name of the `subcorpus`. The `default` value `empty string` refers to the entire corpus. An example for `preloaded/bnc2_tt21` can be `Written Academic` or `1960-1974`."
			},
			"003_gramrels": {
				"in": "query",
				"name": "gramrels",
				"schema": {
					"type": "integer",
					"enum": [
						0,
						1
					]
				},
				"description": "A list of grammatical relations from the correspoding `sketch grammar`."
			},
			"004_corpcheck": {
				"in": "query",
				"name": "corpcheck",
				"schema": {
					"type": "integer",
					"enum": [
						0,
						1
					]
				},
				"description": "Results of the last corpcheck (if available in the compilation log)."
			},
			"005_registry": {
				"in": "query",
				"name": "registry",
				"schema": {
					"type": "integer",
					"enum": [
						0,
						1
					]
				},
				"description": "The content of the registry file (registry_dump and registry_text)."
			},
			"006_subcorpora": {
				"in": "query",
				"name": "subcorpora",
				"schema": {
					"type": "integer",
					"enum": [
						0,
						1
					]
				},
				"description": "A parameter to obtain the list of subcorpora and their sizes (e.g. number of tokens, words)."
			},
			"007_struct_attr_stats": {
				"in": "query",
				"name": "struct_attr_stats",
				"schema": {
					"type": "integer",
					"enum": [
						0,
						1
					]
				},
				"description": "The lexicon sizes of structure attributes."
			},
			"008_format": {
				"in": "query",
				"name": "format",
				"schema": {
					"type": "string",
					"enum": [
						"json",
						"xml",
						"csv",
						"tsv",
						"txt",
						"xls"
					]
				},
				"description": "The `format` of the output. `Empty value` is interpreted as `JSON`. Not every endpoint supports all formats."
			},
			"025_lpos": {
				"in": "query",
				"name": "lpos",
				"schema": {
					"type": "string",
					"enum": [
						"-n",
						"-v",
						"-j",
						"-a",
						"-d",
						"-i"
					]
				},
				"description": "The part of speech of the lemma. The concrete values depend on the corpus. If the corpus contains the `lempos` attribute and `lpos` is empty, the result defaults to the most frequent part of speech of the lemma."
			},
			"039_asyn": {
				"in": "query",
				"name": "asyn",
				"schema": {
					"type": "integer",
					"enum": [
						0,
						1
					]
				},
				"description": "Switches the asynchronous processing on/off. ON = partial results are returned as soon as the first page is filled with results. OFF = results are returned only after the search is completed. Normally, ON is used in the web interface and OFF when using the API."
			},
			"040_json": {
				"in": "query",
				"name": "json",
				"schema": {
					"type": "object",
					"example": "{\"concordance_query\":[{\"queryselector\":\"iqueryrow\",\"iquery\":\"test\"}]}"
				},
				"description": "An optinal way of **wraping parameters**. It is possible to send all parametres via this parameter only.\n\n The most frequent uses are:\n\n `queryselector`: To select the query type. Supported options are: **cqlrow**, **iqueryrow**, **lemmarow**, **charrow**, **phraserow**, **wordrow**. For more information see concordance_query parameters.\n\n `iquery`: Use with `iqueryrow`. \n\n `cql`: Use with `cqlrow`.\n\n `lemma`: Use with `lemmarow`.\n\n `lpos`: The part of speech of the lemma.\n\n `qmcase`: Sets the attribute to its lowercased version, i.e. the data are extracted from a lowercased version of the corpus. It used for case insensitive analysis. 1 = case sensitive), 0 = lowercased corpus/case insensitive).\n\n\n`char`: Use with charrow.\n\n `phrase`: Use with phraserow.\n\n `word`: Use with wordrow\n\n\n`name`: \n\n `pnfilter`: \n\n `inclkwic`: \n\n `filfpos`: \n\n `filtpos`: \n\n `desc`: \n\n `q`: \n\n"
			},
			"041_q": {
				"in": "query",
				"name": "q",
				"schema": {
					"type": "string"
				},
				"example": "q[lemma=\"test\"]",
				"description": "The CQL query. Regexes are supported for `lemma`, `phrase` and `word` types. The `iquery` supports simplified wildcards (see concordance_query[iquery]). If you decide to use the concordance_query in a json parameter, you do not have to use this parameter."
			},
			"044_fmaxitems": {
				"in": "query",
				"name": "fmaxitems",
				"schema": {
					"type": "integer",
					"default": 50
				},
				"description": "The number of items in one response."
			},
			"045_freq_sort": {
				"in": "query",
				"name": "freq_sort",
				"schema": {
					"type": "string",
					"default": "frq",
					"enum": [
						"frq",
						"rel"
					]
				},
				"description": "The identifier of the sorted column. Use `frq` (default) to sort by frequency."
			},
			"054_subcname": {
				"in": "query",
				"name": "subcname",
				"schema": {
					"type": "string"
				},
				"required": true,
				"description": "Name of the subcorpus."
			},
			"055_delete": {
				"in": "query",
				"name": "delete",
				"schema": {
					"type": "integer",
					"default": 0,
					"enum": [
						0,
						1
					]
				},
				"description": "Set to `1` if the corpus should be deleted. Only user subcorpora can be deleted. Nothing will be deleted if left empty (default value == 0)."
			},
			"058_attrs": {
				"in": "query",
				"name": "attrs",
				"schema": {
					"type": "string",
					"default": "word"
				},
				"description": "A list of comma-delimited attributes that are returned together with each token. Other examples are:`word, lc, lemma, tag` etc.."
			},
			"077_default_attr": {
				"in": "query",
				"name": "default_attr",
				"schema": {
					"type": "string"
				},
				"description": "The attribute applied to tokens in the query which do not have an attribute specified explicitly as part of the query."
			},
			"078_refs": {
				"in": "query",
				"name": "refs",
				"schema": {
					"type": "string",
					"example": "=bncdoc.alltyp"
				},
				"description": "The text type (metadata) for which statistics should be calculated from the concordance. The default is `bncdoc.alltyp` (all available text types are included). Text types (attributes and there values) differ between corpora). You can find them in the response of `corpus_info` method in `freqttattrs` or `subcorpattrs` keys. Not all of them have attributes to show."
			},
			"079_attr_allpos": {
				"in": "query",
				"name": "attr_allpos",
				"schema": {
					"type": "string",
					"default": "all",
					"enum": [
						"kw",
						"all"
					]
				},
				"description": "Determines which tokens will be returned with additional attributes defined in `attrs`. `kw` will add the attributes to the KWIC only. `all` will return them with all tokens."
			},
			"080_viewmode": {
				"in": "query",
				"name": "viewmode",
				"schema": {
					"type": "string",
					"enum": [
						"sen",
						"kwic"
					]
				},
				"description": "Switches between sentence view and the KWIC view. `sen` returns complete sentences without trimming them. `kwic` returns the KWIC view with the query in the centre and some context left and right."
			},
			"081_cup_hl": {
				"in": "query",
				"name": "cup_hl",
				"schema": {
					"type": "string",
					"enum": [
						"q",
						"e",
						"c",
						"b"
					]
				},
				"description": "Only used with error-annotated corpora. It determines what should be highlighted. It is set to 'q' for corpora without error annotation. Meaning of individual options:\n\n - `q` -> to higlight query result.\n\n - `e` -> to higlight errors.\n\n - `c` -> to highlight corrections.\n\n - `b` -> to highlight both erros and corrections.\n\n Example of such a corpus can be `preloaded/enwiki_error_sample_sentences`."
			},
			"082_structs": {
				"in": "query",
				"name": "structs",
				"schema": {
					"type": "string",
					"example": "s,g"
				},
				"description": "A list of comma-delimited structures (=structure tags) that should be included in the result."
			},
			"083_fromp": {
				"in": "query",
				"name": "fromp",
				"schema": {
					"type": "integer",
					"example": "1"
				},
				"description": "The number of the page that should be returned."
			},
			"084_pagesize": {
				"in": "query",
				"name": "pagesize",
				"schema": {
					"type": "integer",
					"example": "20"
				},
				"description": "The number of lines in the concordance."
			},
			"085_kwicleftctx": {
				"in": "query",
				"name": "kwicleftctx",
				"schema": {
					"type": "string",
					"example": "100#"
				},
				"description": "The size of the left context in KWIC view. Number of tokens."
			},
			"086_kwicrightctx": {
				"in": "query",
				"name": "kwicrightctx",
				"schema": {
					"type": "string",
					"example": "100#"
				},
				"description": "The size of the right context in KWIC view. Number of tokens."
			},
			"094_fpage": {
				"in": "query",
				"name": "fpage",
				"schema": {
					"type": "integer"
				},
				"description": "The number of the response batch (page). The number of items in each batch is specified by `fmaxitems`."
			},
			"095_group": {
				"in": "query",
				"name": "group",
				"schema": {
					"type": "integer",
					"enum": [
						1,
						0
					]
				},
				"description": "If there are more attributes (e.g. m1attr, m2attr), the results can be grouped by the first column/attribute."
			},
			"096_showpoc": {
				"in": "query",
				"name": "showpoc",
				"schema": {
					"type": "integer",
					"enum": [
						1,
						0
					]
				},
				"description": "Includes the percentage of the concordance in the result."
			},
			"097_showreltt": {
				"in": "query",
				"name": "showreltt",
				"schema": {
					"type": "integer",
					"enum": [
						1,
						0
					]
				},
				"description": "Includes relative in text types value in the result."
			},
			"098_showrel": {
				"in": "query",
				"name": "showrel",
				"schema": {
					"type": "integer",
					"enum": [
						1,
						0
					]
				},
				"description": "Includes the relative frequency in the result."
			},
			"099_freqlevel": {
				"in": "query",
				"name": "freqlevel",
				"schema": {
					"type": "integer",
					"enum": [
						1,
						2,
						3,
						4,
						5,
						6
					]
				},
				"description": "The number of attributes for which the frequencies should be counted."
			},
			"100_ml1attr": {
				"in": "query",
				"name": "ml1attr",
				"required": true,
				"schema": {
					"type": "string",
					"example": "word"
				},
				"description": "Used to count the frequency of positional attributes [attributes](https://www.sketchengine.eu/my_keywords/positional-attribute/) or structure attributes (metadata/text types) of any token in the concordance.\\n\\n A maximum of 6 attributes is allowed (e.g. ml2attr, ml3attr). At least one attribute is required."
			},
			"101_ml1ctx": {
				"in": "query",
				"name": "ml1ctx",
				"required": true,
				"schema": {
					"type": "string",
					"example": "-1<0"
				},
				"description": " Position of the selected attribute in the concordance. **Minus** means **left** context (-1<0). **Plus** means **right** context (6>0). **At least one attribute is required, the others are optional.** Every attribute (ml1attr, ml2attr. etc.) needs it's **own** context position (e.g. if 3 attributes are selected three context position **needs to** be set ml1ctx, ml2ctx, ml3ctx).\n\n\n**Positions can be referenced as follows:**\n\n `integer number` - where **0** is the first token in **KWIC**, **-1** the rightmost token in the left context etc.\n\n `1:x` - where **x** is one of the corpus structures (e.g. “doc” or “s” if the corpus has the particular markup). Its meaning is the first token in the structure, except when it is the right boundary of a range - then it is the last token in the structure. Also, other numbers can be used, e.g. -2:x, 3:x, etc. (-1 is the same as 1 with meaning “structure containing KWIC”)\n\n `a<0` - where **a** stands for a position reference as described in the first two points with meaning '**a** positions before/after the firs KWIC position' (so this is equivalent to **a**)\n\n `a>0` - where **a** stands for the same position reference with meaning 'positions before/after the last KWIC position'\n\n in the previous two points, if **0** is substituted with a natural number **k**, it means 'before/after **k**-th collocation' instead of 'before/after KWIC'. Collocations are special token groups in the context, that can be added using positive filters (see below).\n\n\n`Ranges` can be referenced as a~b where **a**, **b** stand for token identifiers as above. Examples of positions and ranges:\n\n `-1<0` - rightmost token in the left context\n\n `3>0` - third token in right context\n\n `0>0` - last token in KWIC\n\n `0<0` - first token in KWIC\n\n `0<0~0>0` - range of KWIC\n\n `-1<0~1>0` - range of KWIC with one token from the left context and one from the right context\n\n `1:s` - first token in the sentence containing KWIC (or its first token)\n\n `1:s>0` - first token in the sentence containing KWIC (or its last token)\n\n `0<1` - first token of the first-added collocation.\n\n\n`Examples:`\n\n sword/ **1>0~3>0**\n\n sword/ **1>0~3>0**\n\n slemma/ **0<0~0>0**\n\n sword/i **-1**\n\n sword/ **0** word/ir **-1<0** tag/r **-2<0**\n\n "
			},
			"127_concordance_query_queryselector": {
				"in": "query",
				"name": "concordance_query[queryselector]",
				"schema": {
					"type": "string",
					"enum": [
						"iquery",
						"cqlrow",
						"lemmarow",
						"charrow",
						"wordrow",
						"phraserow"
					]
				},
				"description": "The query type. You can send it directly or via the `json` parameter, the results are the same."
			},
			"128_concordance_query_iquery": {
				"in": "query",
				"name": "concordance_query[iquery]",
				"schema": {
					"type": "string"
				},
				"description": "Only works when `queryselector` is set to `iqueryrow`. Type a word or phrase.\n\n These special wildcards are supported .\n\nUse the `asterisk (*)` for any number of unspecified characters. Use a `question mark (?)` for exactly one unspecified character. Use the `pipe (|)` to include more than one word or phrase. Use `two hyphens (--)` to find a word which is  hyphenated, non-hyphenated or spelt as two separate words."
			},
			"129_concordance_query_cql": {
				"in": "query",
				"name": "concordance_query[cql]",
				"schema": {
					"type": "string"
				},
				"description": "Only works when `queryselector` is set to `cqlrow`. Type the query using the [cql](https://www.sketchengine.eu/documentation/corpus-querying/) query language."
			},
			"130_concordance_query_lemma": {
				"in": "query",
				"name": "concordance_query[lemma]",
				"schema": {
					"type": "string"
				},
				"description": "Only works when `queryselector` is set to `lemmarow`. Type the lemma. Regex is supported."
			},
			"131_concordance_query_char": {
				"in": "query",
				"name": "concordance_query[char]",
				"schema": {
					"type": "string"
				},
				"description": "Only works when `queryselector` is set to `charrow`. Type the characters that the tokens should contain. Regex is supported."
			},
			"132_concordance_query_word": {
				"in": "query",
				"name": "concordance_query[word]",
				"schema": {
					"type": "string"
				},
				"description": "Only works when `queryselector` is set to `wordrow`. Type the word form. Regex is supported."
			},
			"133_concordance_query_phrase": {
				"in": "query",
				"name": "concordance_query[phrase]",
				"schema": {
					"type": "string"
				},
				"description": "Only works when `queryselector` is set to `phraserow`. Type the phrase. Regex is supported."
			},
			"134_errcorr_switch": {
				"in": "query",
				"name": "errcorr_switch",
				"schema": {
					"type": "string",
					"enum": [
						"corr",
						"err"
					]
				},
				"description": "(Only for error-annotated corpora.) Determines what should be highlighted. Corr means **correction** and err means **error**. An **example** of such a corpus is `preloaded/enwiki_error_sample_sentences`."
			},
			"135_cup_err_code": {
				"in": "query",
				"name": "cup_err_code",
				"schema": {
					"type": "string",
					"enum": [
						".*",
						"lexicosemantic",
						"punct",
						"spelling",
						"style",
						"typographical",
						"unclassified"
					]
				},
				"description": "(Only for error-annotated corpora). Determines which error type to higlight. An example of such a corpus is `preloaded/enwiki_error_sample_sentences`."
			},
			"136_cup_err": {
				"in": "query",
				"name": "cup_err",
				"schema": {
					"type": "string"
				},
				"description": "(Only for error-annotated corpora.) An error token to search."
			},
			"137_cup_corr": {
				"in": "query",
				"name": "cup_corr",
				"schema": {
					"type": "string"
				},
				"description": "(Only for error-annotated corpora.) A correction token to search."
			},
			"141_ml2attr": {
				"in": "query",
				"name": "ml2attr",
				"schema": {
					"type": "string",
					"example": "word"
				},
				"description": "Used to count the frequency of positional attributes [attributes](https://www.sketchengine.eu/my_keywords/positional-attribute/). Just like `ml1attr` but optional."
			},
			"142_ml2ctx": {
				"in": "query",
				"name": "ml2ctx",
				"schema": {
					"type": "string",
					"example": "-1<0"
				},
				"description": "Position of the selected attribute in the concordance. Minus means left context (-1<0). Plus means right context (6>0). Just like ml1ctx but optional."
			},
			"143_ml3attr": {
				"in": "query",
				"name": "ml3attr",
				"schema": {
					"type": "string",
					"example": "word"
				},
				"description": "Used to count the frequency of positional attributes [attributes](https://www.sketchengine.eu/my_keywords/positional-attribute/). Just like `ml1attr` but optional."
			},
			"144_ml3ctx": {
				"in": "query",
				"name": "ml3ctx",
				"schema": {
					"type": "string",
					"example": "-1<0"
				},
				"description": "Position of the selected attribute in the concordance. Minus means left context (-1<0). Plus means right context (6>0). Just like ml1ctx but optional."
			},
			"145_ml4attr": {
				"in": "query",
				"name": "ml4attr",
				"schema": {
					"type": "string",
					"example": "word"
				},
				"description": "Used to count the frequency of positional attributes [attributes](https://www.sketchengine.eu/my_keywords/positional-attribute/). Just like `ml1attr` but optional."
			},
			"146_ml4ctx": {
				"in": "query",
				"name": "ml4ctx",
				"schema": {
					"type": "string",
					"example": "-1<0"
				},
				"description": "Position of the selected attribute in the concordance. Minus means left context (-1<0). Plus means right context (6>0). Just like ml1ctx but optional."
			},
			"147_ml5attr": {
				"in": "query",
				"name": "ml5attr",
				"schema": {
					"type": "string",
					"example": "word"
				},
				"description": "Used to count the frequency of positional attributes [attributes](https://www.sketchengine.eu/my_keywords/positional-attribute/). Just like `ml1attr` but optional."
			},
			"148_ml5ctx": {
				"in": "query",
				"name": "ml5ctx",
				"schema": {
					"type": "string",
					"example": "-1<0"
				},
				"description": "Position of the selected attribute in the concordance. Minus means left context (-1<0). Plus means right context (6>0). Just like ml1ctx but optional."
			},
			"149_ml6attr": {
				"in": "query",
				"name": "ml6attr",
				"schema": {
					"type": "string",
					"example": "word"
				},
				"description": "Used to count the frequency of positional attributes [attributes](https://www.sketchengine.eu/my_keywords/positional-attribute/). Just like `ml1attr` but optional."
			},
			"150_ml6ctx": {
				"in": "query",
				"name": "ml6ctx",
				"schema": {
					"type": "string",
					"example": "-1<0"
				},
				"description": "Position of the selected attribute in the concordance. Minus means left context (-1<0). Plus means right context (6>0). Just like ml1ctx but optional."
			},
			"155_create": {
				"in": "query",
				"name": "create",
				"schema": {
					"type": "integer",
					"default": 0,
					"enum": [
						0,
						1
					]
				},
				"description": "Set to `1` if new subcorpus should be created. Subcorpus will not be created if left empty (default value == 0)."
			},
			"156_q_subcorp": {
				"in": "query",
				"name": "q",
				"schema": {
					"type": "object",
					"example": "q=alemma,[lc=\"test\" | lemma_lc=\"test\"]"
				},
				"description": "Query for creating subcorpora from concordance. \n\nThe search criteria are specified within brackets following a prefix like `alemma` or `aword`. This prefix often indicates the type of linguistic search (e.g., lemma-based, word-based). The criteria within the brackets can include checks for specific words, lemmas, parts of speech and more, using operators like | (OR), & (AND), and regular expressions. \n\nThe lists of available attributes, pos tags for specific corpus can be obtained via `/search/corp_info`.\n\n\n`Examples:`\n\n\n - Simple word or lemma search in the BNC corpus: \n\n    **q=alemma,[lc=\"test\" | lemma_lc=\"test\"]**\n\n\n - Search for nouns with the lemma 'test' in a case-sensitive manner: \n\n    **q=alemma,[lempos_lc=\"(test)-n\"]**\n\n\n - Search for verbs with the lemma 'test', case-insensitive: \n\n    **q=alemma,[lempos=\"(test)-v\"]**\n\n\n - Searching for a specific phrase 'test' in a case-sensitive manner: \n\n    **q=aword,[word=\"test\"]**\n\n\n - Searching for the numeral '1955': \n\n    **q=alemma,[word=\"1955\" & tag=\"CD\"]**\n\n\n - Regex-based search for words containing the character 'h': \n\n    **q=alemma,[word=\".\\*h.\\*\"]**\n\n\n - Complex search involving the lemma 'book' followed by up to three words, then a verb: \n\n    **q=alemma,[lemma=\"book\"][]{1,3}[tag=\"V.\\*\"]**"
			},
			"157_struct": {
				"in": "query",
				"name": "struct",
				"schema": {
					"type": "string",
					"example": "doc"
				},
				"description": "Which corpus structure should be used in new subcorpus. Used withim concordance type of subcorpus. The lists of structures can be obtained via `/search/corp_info`."
			},
			"160_json_subcorp": {
				"in": "query",
				"name": "json",
				"schema": {
					"type": "object",
					"example": {
						"sca_bncdoc.alltyp": [
							"Spoken context-governed"
						]
					}
				},
				"description": "Used to specify text types for a subcorpus. Takes a JSON object as input, where the key-value pairs define the specific attributes. The attributes can vary depending on the corpus.\n\n When using the json parameter in a query, you can define a JSON object with one or more attributes. Each attribute can have a single value or an array of values.\n\n\nThe list of available text types for specific corpus can be obtained via `/search/corp_info` just add `sca_` in front the name (see examples).\n\n\n`Examples:`\n\n\n - To create a subcorpus based on a specific spoken text type from the BNC corpus: \n\n    **{\"sca_bncdoc.alltyp\":[\"Spoken context-governed\"]}**\n\n\n - To filter texts from the BNC corpus that are both spoken context-governed and spoken demographic: \n\n    **{\"sca_bncdoc.alltyp\":[\"Spoken context-governed\",\"Spoken demographic\"]}**\n\n\n - To select texts from the BNC corpus from a specific time period (1960-1974): \n\n    **{\"sca_bncdoc.alltim\":[\"1960-1974\"]}**\n\n\n - To create a subcorpus with texts from specific authors and time periods, along with regional specifications: \n\n    **{\"sca_bncdoc.author\": [\"Author1\",\"Author2\",...],\"sca_bncdoc.alltim\": [\"1985-1993\",\"1975-1984\"], \"sca_bncdoc.wripp\": [\"UK (unspecific)\",\"Ireland\"]}**\n\n\n - To filter texts from the Ententen corpus based on domain and topic: \n\n    **{\"sca_doc.tld\":[\"org\",\"com\"], \"sca_doc.topic\": [\"arts\",\"beauty & fashion\",\"cars & bikes\",\"culture & entertainment\"]}**\n\n\n - For a user-specific corpus, filtering based on document ID and filename: \n\n    **{\"sca_doc.id\":[\"file29173711\"],\"sca_doc.filename\":[\"Filename.pdf\"]}**"
			}

		},
		"schemas": {
			"01_corp_info": {
				"type": "object",
				"properties": {
					"wposlist": {
						"description": "A list of WPOS (`Word Part Of Speech`). Presented as a pair of WPOS names and regular expression matching the WPOS tags.",
						"type": "array",
						"items": {
							"type": "array",
							"items": {
								"type": "string",
								"example": "[\"adjective\",\"J.*\"]",
								"description": "At [tagsets](https://www.sketchengine.eu/tagsets/) you can find the meaning of used POS tags for 55 languages. Make sure you select the correct language."
							}
						}
					},
					"lposlist": {
						"description": "A list of LPOS (`Lemma Part Of Speech`). Presented as a pair of LPOS names and LPOS tags. Used in Concordance forms.",
						"type": "array",
						"items": {
							"type": "array",
							"items": {
								"type": "string",
								"example": "[\"adjective\",\"-j\"]",
								"description": "Other examples can be [ \"adverb\", \"-a\" ], [ \"conjunction\", \"-c\" ], [ \"noun\", \"-n\" ] etc. To see all pairs of LPOSLIST you execute the endpoint via the `Try it Out button`."
							}
						}
					},
					"wsposlist": {
						"description": "Has the same format as LPOSLIST but WSPOSLIST is used in Word Sketch and Thesaurus forms.",
						"type": "array",
						"items": {
							"type": "array",
							"items": {
								"type": "string",
								"example": "[\"adjective\",\"-j\"]",
								"description": "Same as in LPOSLIST. To see all pairs of WSPOSLIST you execute the endpoint via the `Try it Out button`.'"
							}
						}
					},
					"attributes": {
						"description": "A list of objects containing detailed information about attributes occuring in specified corpora.",
						"type": "array",
						"items": {
							"type": "object",
							"properties": {
								"name": {
									"type": "string",
									"example": "lempos_lc",
									"description": "Name of attribute. Lempos_lc = Lemma part of speech lowercase."
								},
								"id_range": {
									"type": "integer",
									"example": 524493,
									"description": "The number of attributes of the given name in the corpus. Each is counted only once even if it appears in corpus many times."
								},
								"label": {
									"type": "string",
									"example": "lempos(lowercase)",
									"description": "An extra description."
								},
								"dynamic": {
									"type": "string",
									"example": "utf8lowercase",
									"description": "Represents the rule according which the attribute should be derived from the original attribute. The attribute `lempos_lc` is derived from `lempos` to save disk space etc. [Read more](https://www.sketchengine.eu/documentation/corpus-configuration-file-all-features/#Dynamicattributes)."
								},
								"fromattr": {
									"type": "string",
									"example": "lempos",
									"description": "A name of attribute this attribute is derived from. Empty string if the attribute is not derived from any."
								}
							}
						}
					},
					"structs": {
						"description": "A list of structures in the corpus.",
						"type": "array",
						"items": {
							"type": "string"
						}
					},
					"name": {
						"type": "string",
						"example": "British National Corpus (BNC)",
						"description": "The full name of the corpus."
					},
					"lang": {
						"type": "string",
						"example": "English",
						"description": "The language of the corpus."
					},
					"infohref": {
						"type": "string",
						"example": "https://www.sketchengine.eu/british-national-corpus/",
						"description": "An URL with more information about the corpus. Empty string if none."
					},
					"info": {
						"type": "string",
						"example": "A balanced English corpus of samples of a written and spoken language of British English from the later part of the 20th century (1969–1994). The spoken part is accompanied by audio recordings.",
						"description": "More information about the corpus."
					},
					"encoding": {
						"type": "string",
						"example": "UTF-8",
						"description": "The used character encoding in the corpus."
					},
					"tagsetdoc": {
						"type": "string",
						"example": "https://www.sketchengine.eu/english-treetagger-pipeline-2/",
						"description": "An URL with more information about the POS tagger used in the corpus. Information like meanings of POS tags, comparition with other tagsets for specified language etc."
					},
					"defaultattr": {
						"type": "string",
						"example": "lc",
						"description": "The default attribute for the corpus. Usually `word` or `lc`."
					},
					"starattr": {
						"type": "string"
					},
					"unicameral": {
						"type": "boolean",
						"example": false,
						"description": "A boolean value indicating if the corpus is unicameral (not distinguishing between upper and lower case)."
					},
					"righttoleft": {
						"type": "boolean",
						"example": false,
						"description": "The order of writing in language of the used corpus."
					},
					"errsetdoc": {
						"type": "string"
					},
					"wsattr": {
						"type": "string",
						"example": "lempos_lc",
						"description": "The attribute name for which word sketches are computed, e.g. `lempos`."
					},
					"wsdef": {
						"type": "string",
						"example": "/corpora/wsdef/english-penn_tt-3.1.wsdef.m4",
						"description": "A path to the `used` word sketches grammar definition file."
					},
					"termdef": {
						"type": "string",
						"example": "/corpora/wsdef/english-penn_tt-terms-3.1.termdef.m4",
						"description": "A path to the term grammar definition file used in the corpus."
					},
					"diachronic": {
						"description": "A list of diachronic subcorporas. Diachronic corpus is corpus with timestamps to watch development of the language in time.",
						"type": "array",
						"items": {
							"type": "string",
							"example": "bncdoc.year"
						}
					},
					"aligned": {
						"description": "A list of aligned corpora names. `Example used here is from different corpus because BNC corpus is not parallel.`",
						"type": "array",
						"items": {
							"type": "array",
							"items": {
								"type": "string",
								"example": "a_czech",
								"description": "Just the corpname of the aligned corpora. Parallel corpora support just two languages (corpora)."
							}
						}
					},
					"aligned_details": {
						"description": "Is shown only if the specified corpus is parallel. A list of dictionaries containing detailed information about each aligned subcorpus.",
						"type": "array",
						"items": {
							"type": "object",
							"properties": {
								"name": {
									"type": "string",
									"example": "Example_1",
									"description": "The name of the aligned corpus."
								},
								"language_name": {
									"type": "string",
									"example": "Czech",
									"description": "The language of the aligned corpus."
								},
								"Wposlist": {
									"type": "array",
									"items": {
										"type": "object",
										"properties": {
											"n": {
												"type": "string",
												"example": "noun",
												"description": "The name of the part of speech category"
											},
											"v": {
												"type": "string",
												"example": "k1.*",
												"description": "A regex matching the category"
											}
										}
									}
								},
								"Lposlist": {
									"type": "array",
									"items": {
										"type": "object",
										"properties": {
											"n": {
												"type": "string",
												"example": "noun",
												"description": "Name of part of speech category"
											},
											"v": {
												"type": "string",
												"example": "-n",
												"description": "The shortcut for better representation of a speech category."
											}
										}
									}
								},
								"has_case": {
									"type": "boolean",
									"description": "Represent if the language of aligned corpus differentiates between upper case and lower case."
								},
								"has_lemma": {
									"type": "boolean",
									"description": "Represent if the language of aligned corpus has lemma of not."
								},
								"tagsetdoc": {
									"type": "string",
									"example": "https://www.sketchengine.eu/tagset-reference-for-czech",
									"description": "URL with closer information."
								}
							}
						}
					},
					"freqttattrs": {
						"description": "A list of attributes (text types) that will be used for Frequency. Text types are metadata attached to the corpus structures. You can access it via Sketch Engine dashboard -> Corpus Info -> Text Type Analysis.",
						"type": "array",
						"items": {
							"type": "string",
							"example": "[\"bncdoc.alltyp\", \"bncdoc.alltim\", \"bncdoc.author\", \"bncdoc.wripp\", \"bncdoc.sporeg\", \"bncdoc.scgdom\", \"bncdoc.wridom\", \"bncdoc.spolog\", \"event.desc\", \"bncdoc.wrimed\", \"bncdoc.year\", \"bncdoc.genre\"]"
						}
					},
					"subcorpattrs": {
						"description": "A list of subcorpus attributes for the corpus.",
						"type": "array",
						"items": {
							"type": "string",
							"example": "[\"bncdoc.alltyp\", \"bncdoc.alltim\", \"bncdoc.author\", \"bncdoc.wripp\", \"bncdoc.sporeg\", \"bncdoc.scgdom\", \"bncdoc.wridom\", \"bncdoc.spolog\", \"event.desc\", \"bncdoc.wrimed\", \"bncdoc.year\", \"bncdoc.genre\"]"
						}
					},
					"shortref": {
						"type": "string",
						"example": "=bncdoc.alltyp",
						"description": "The attribute of a structure to display as a default reference in the left-hand column of a concordance. The syntax is like `=structure.attribute`, e.g. `=doc.id` for displaying only the value of `doc.id`."
					},
					"docstructure": {
						"type": "string",
						"example": "bncdoc",
						"description": "A structures that is considered as individual documents. Usually `doc`."
					},
					"newversion": {
						"type": "string",
						"example": "",
						"description": "Information about the new version of the corpus, if available. Empty string if not."
					},
					"structures": {
						"description": "A list of structures appearing in corpus.",
						"type": "array",
						"items": {
							"type": "object",
							"properties": {
								"name": {
									"type": "string",
									"example": "head",
									"description": "The name of the structure."
								},
								"label": {
									"type": "string",
									"description": "Just some extra information. Empty string if none."
								},
								"attributes": {
									"description": "More detailed information.",
									"type": "array",
									"items": {
										"type": "object",
										"properties": {
											"name": {
												"type": "string",
												"example": "rend",
												"description": "Name of attribute."
											},
											"label": {
												"type": "string",
												"example": "",
												"description": "An extra information about attribute. Empty string if none."
											},
											"dynamic": {
												"type": "string",
												"description": "Dynamic (derived) attribute. Empty string if none. [Read more](https://www.sketchengine.eu/documentation/corpus-configuration-file-all-features/#Dynamicattributes)"
											},
											"fromattr": {
												"type": "string",
												"description": "A name of attribute this attribute is derived from. Empty string if none."
											},
											"size": {
												"type": "integer",
												"example": 5,
												"description": "Number of occurences."
											}
										}
									}
								},
								"size": {
									"type": "string",
									"example": 14868944,
									"description": "Number of occurences of `head` structure in this case."
								}
							}
						}
					},
					"is_error_corpus": {
						"type": "boolean",
						"example": false,
						"description": "A boolean value indicating if the corpus is an error corpus (not compiled etc.)."
					},
					"structctx": {
						"type": "string",
						"example": "",
						"description": "The structural context for the corpus. Empty string if none."
					},
					"deffilerlink": {
						"type": "boolean",
						"example": false,
						"description": "A boolean value indicating if the default filter link is enabled."
					},
					"defaultstructs": {
						"description": "A list of default structures for the corpus.",
						"type": "array",
						"items": {
							"type": "string"
						}
					},
					"wsttattrs": {
						"type": "string",
						"description": "The text types for which the word highlights [Read more](https://www.sketchengine.eu/find-x-word-highlights/) are computed."
					},
					"terms_compiled": {
						"type": "boolean",
						"example": true,
						"description": "A boolean value indicating if the terms file is compiled."
					},
					"compiled": {
						"type": "string",
						"example": "06/30/2017 07:34:25",
						"description": "A date of compilation in format `mm/dd/yyyy hh:mm:ss`."
					},
					"gramrels": {
						"type": "array",
						"items": {
							"type": "string"
						}
					},
					"sizes": {
						"type": "object",
						"properties": {
							"tokencount": {
								"type": "string",
								"example": "112345722"
							},
							"wordcount": {
								"type": "string",
								"example": "96134547"
							},
							"doccount": {
								"type": "string",
								"example": "4054",
								"description": "Document counter."
							},
							"parcount": {
								"type": "string",
								"example": "1514906",
								"description": "Paragraph counter."
							},
							"sentcount": {
								"type": "string",
								"example": "6052190",
								"description": "Sentences counter."
							},
							"normsum": {
								"type": "string",
								"example": "96134547",
								"description": "Wordcount after normalization."
							}
						}
					},
					"alsizes": {
						"description": "A list of tuples containing sizes of aligned corpora.",
						"type": "array",
						"items": {
							"type": "string"
						}
					},
					"registry_dump": {
						"type": "string",
						"description": "The registry dump for the corpus (detailed information about corpus setting), if the registry parameter is set."
					},
					"registry_text": {
						"type": "string",
						"description": "The registry text for the corpus (detailed information about corpus setting), if the registry parameter is set."
					},
					"subcorpora": {
						"type": "array",
						"items": {
							"type": "object",
							"properties": {
								"n": {
									"type": "string",
									"example": "Test",
									"description": "A name of subcorpus."
								},
								"name": {
									"type": "string",
									"example": "Test",
									"description": "A name of subcorpus."
								},
								"user": {
									"type": "integer",
									"example": 1,
									"description": "Represent if subcorpora is created by user or not."
								},
								"tokens": {
									"type": "integer",
									"example": 271454,
									"description": "Number of tokens in subcorpus."
								},
								"relsize": {
									"type": "integer",
									"example": 0.24162379765559744,
									"description": "The percentage of subcorpus size from total corpus size."
								},
								"words": {
									"type": "integer",
									"example": 232283,
									"description": "Number of words in subcorpus."
								},
								"struct": {
									"type": "string",
									"example": "s"
								},
								"query": {
									"type": "string",
									"example": "Q:q[lc=\"dog\" | lemma_lc=\"dog\"]"
								}
							}
						}
					},
					"api_version": {
						"type": "string",
						"example": "5.62.3",
						"description": "Current API version."
					},
					"manatee_version": {
						"type": "string",
						"example": "2.36.7-SkE-2.219.2",
						"description": "Current version of Manatee."
					},
					"request": {
						"description": "Just summary section of parsed query parameters used in this endpoint call. These parameters are all documented in the beggining of every endpoint box (after you unwrap the endpoint).",
						"type": "object",
						"properties": {
							"subcorpora": {
								"type": "string",
								"example": "1"
							},
							"struct_attr_stats": {
								"type": "string",
								"example": "1"
							},
							"corpname": {
								"type": "string",
								"example": "preloaded/bnc2_tt21"
							}
						}
					}
				}
			},
			"03_corpora_list": {
				"type": "object",
				"properties": {
					"id": {
						"description": "Unique numeric `corpus ID` for corpus building.",
						"type": "integer"
					},
					"owner_id": {
						"description": "Unique numeric `owner ID` (usually you).",
						"type": "integer"
					},
					"owner_name": {
						"description": "Corpus `owner name` (usually you).",
						"type": "string"
					},
					"corpname": {
						"description": "Unique `corpus name` for corpus querying.",
						"type": "string"
					},
					"language_id": {
						"description": "Language iso-code. `ISO 639-1`.",
						"type": "string"
					},
					"language_name": {
						"type": "string",
						"description": "Language name in `English`."
					},
					"tagset_id": {
						"type": "integer",
						"description": "`Tagset ID`. Tagset is list of part-of-speech tags (POS tags) for specified language. They are `preselected` to the most relevant one and can be changed only in user corpora. `Tagsets` can be refered also as `templates`."
					},
					"sketch_grammar_id": {
						"type": "string",
						"description": "`Sketch grammar ID`. Sketch grammar is a series of rules written in the CQL query language that search for collocations in a text corpus and categorize them according to their grammatical relations."
					},
					"term_grammar_id": {
						"type": "string",
						"description": "`Term grammar ID`. Term grammar tells Sketch Engine which words and phrases should indentify as terms."
					},
					"sizes": {
						"type": "object",
						"description": "Corpus sizes. `Null` if corpus is not compiled.",
						"properties": {
							"doccount": {
								"type": "integer",
								"description": "Total number of `documents` in corpus."
							},
							"parcount": {
								"type": "integer",
								"description": "Total number of `paragraphs` in corpus."
							},
							"sentcount": {
								"type": "integer",
								"description": "Total number of `sentences` in corpus."
							},
							"wordcount": {
								"type": "integer",
								"description": "Total number of `words` (tokens minus punctuation etc.) in corpus."
							},
							"tokencount": {
								"type": "integer",
								"description": "Total number of `tokens` in corpus."
							}
						}
					},
					"created": {
						"type": "string",
						"description": "Date and time of corpus creation in format `YYYY-MM-DD HH:MM:SS`."
					},
					"needs_recompiling": {
						"type": "boolean",
						"description": "`True` if corpus documents have been altered since last compilation."
					},
					"user_can_read": {
						"type": "boolean",
						"description": "Corpus can be queried a `specific user`. Ignore all corpora where this is false."
					},
					"user_can_refer": {
						"type": "boolean",
						"description": "Corpus can be used as a `reference corpus` even by anonymous users."
					},
					"user_can_upload": {
						"type": "boolean",
						"description": "Corpus is owned by you or shared with you. You can upload documents to it."
					},
					"user_can_manage": {
						"description": "Corpus is owned by you or shared with you with `full privileges`.",
						"type": "boolean"
					},
					"is_shared": {
						"type": "boolean",
						"description": "True if corpus is shared with other users."
					},
					"new_version": {
						"type": "string",
						"description": "If set, the old corpus is deprecated in favor of a new one."
					},
					"name": {
						"type": "string",
						"description": "Corpus name. `Given by user.`"
					},
					"info": {
						"type": "string",
						"description": "Additional info about corpus."
					},
					"aligned": {
						"description": "List of other corpora (corpus ID) within the `same` multi-lingual set (parallel corpus).",
						"type": "array",
						"items": {
							"type": "string"
						}
					},
					"docstructure": {
						"type": "string",
						"description": "Structure in which individual documents should be wrapped. Usually `doc`."
					}
				}
			},
			"06_concordance": {
				"type": "object",
				"properties": {
					"Lines": {
						"type": "array",
						"items": {
							"type": "object",
							"properties": {
								"toknum": {
									"type": "integer",
									"example": 10336
								},
								"hitlen": {
									"type": "integer",
									"example": 1
								},
								"Refs": {
									"type": "array",
									"items": {
										"type": "string",
										"example": "Written books and periodicals"
									}
								},
								"Tbl_refs": {
									"type": "array",
									"items": {
										"type": "string",
										"example": "Written books and periodicals"
									}
								},
								"Left": {
									"type": "array",
									"items": {
										"type": "object",
										"properties": {
											"strc": {
												"type": "string",
												"example": "<s>"
											}
										}
									}
								},
								"Kwic": {
									"type": "array",
									"items": {
										"type": "object",
										"properties": {
											"str": {
												"type": "string",
												"example": "dogs"
											},
											"coll": {
												"type": "integer",
												"example": 1
											}
										}
									}
								},
								"Right": {
									"type": "array",
									"items": {
										"type": "object",
										"properties": {
											"str": {
												"type": "string",
												"example": "</s>"
											}
										}
									}
								},
								"Links": {
									"type": "array",
									"items": {
										"type": "string"
									}
								},
								"linegroup": {
									"type": "string",
									"example": "_"
								},
								"linegroup_id": {
									"type": "integer",
									"example": 0
								}
							}
						}
					},
					"fromp": {
						"type": "integer",
						"example": 1
					},
					"concsize": {
						"type": "integer",
						"example": 12087
					},
					"concordance_size_limit": {
						"type": "integer",
						"example": 10000
					},
					"Sort_idx": {
						"type": "array",
						"items": {
							"type": "string"
						}
					},
					"righttoleft": {
						"type": "boolean",
						"example": false
					},
					"Aligned_rtl": {
						"type": "array",
						"items": {
							"type": "string"
						}
					},
					"numofcolls": {
						"type": "integer",
						"example": 0
					},
					"finished": {
						"type": "integer",
						"example": 1
					},
					"fullsize": {
						"type": "integer",
						"example": 12087
					},
					"relsize": {
						"type": "integer",
						"example": 107.59
					},
					"q": {
						"type": "array",
						"items": {
							"type": "string",
							"example": "q[lc=\\\"dog\\\" | lemma_lc=\\\"dog\\\"]"
						}
					},
					"Desc": {
						"type": "object",
						"properties": {
							"op": {
								"type": "string",
								"example": "Query"
							},
							"arg": {
								"type": "string",
								"example": "[lc=\\\"dog\\\" | lemma_lc=\\\"dog\\\"]"
							},
							"nicearg": {
								"type": "string",
								"example": "dog"
							},
							"rel": {
								"type": "integer",
								"example": 107.59
							},
							"size": {
								"type": "integer",
								"example": 12087
							},
							"tourl": {
								"type": "string",
								"example": "q=q%5Blc%3D%22dog%22+%7C+lemma_lc%3D%22dog%22%5D"
							}
						}
					},
					"port": {
						"type": "integer",
						"example": 0
					},
					"gdex_scores": {
						"type": "array",
						"items": {
							"type": "string"
						}
					},
					"sc_strcts": {
						"type": "array",
						"items": {
							"type": "array",
							"items": {
								"type": "string",
								"example": "bncdoc"
							}
						}
					},
					"api_version": {
						"type": "string",
						"example": "5.63.1"
					},
					"manatee_version": {
						"type": "string",
						"example": "2.36.7-SkE-2.221"
					},
					"request": {
						"type": "object",
						"properties": {
							"concordance_query": {
								"type": "array",
								"items": {
									"type": "object",
									"properties": {
										"queryselector": {
											"type": "string",
											"example": "iqueryrow"
										},
										"iquery": {
											"type": "string",
											"example": "dog"
										}
									}
								}
							},
							"corpname": {
								"type": "string",
								"example": "preloaded/bnc2_tt21"
							},
							"kwicleftctx": {
								"type": "string",
								"example": "100#"
							},
							"structs": {
								"type": "string",
								"example": "s,g"
							},
							"viewmode": {
								"type": "string",
								"example": "sen"
							},
							"attr_allpos": {
								"type": "string",
								"example": "all"
							},
							"fromp": {
								"type": "string",
								"example": "1"
							},
							"json": {
								"type": "string",
								"example": "{\\\"concordance_query\\\":[{\\\"queryselector\\\":\\\"iqueryrow\\\",\\\"iquery\\\":\\\"dog\\\"}]}"
							},
							"kwicrightctx": {
								"type": "string",
								"example": "100#"
							},
							"refs": {
								"type": "string",
								"example": "=bncdoc.alltyp"
							},
							"cup_hl": {
								"type": "string",
								"example": "q"
							},
							"attrs": {
								"type": "string",
								"example": "word"
							},
							"pagesize": {
								"type": "string",
								"example": "20"
							}
						}
					}
				}
			},
			"07_subcorp": {
				"type": "object",
				"properties": {
					"subcname": {
						"type": "string",
						"example": "Australian domain .au"
					},
					"SubcorpList": {
						"type": "array",
						"items": {
							"type": "object",
							"properties": {
								"n": {
									"type": "string",
									"example": "Australian domain .au"
								},
								"name": {
									"type": "string",
									"example": "Australian domain .au"
								},
								"user": {
									"type": "integer",
									"example": 0
								}
							}
						}
					},
					"api_version": {
						"type": "string",
						"example": "5.63.1"
					},
					"manatee_version": {
						"type": "string",
						"example": "2.36.7-SkE-2.221"
					},
					"request": {
						"type": "object",
						"properties": {
							"corpname": {
								"type": "string",
								"example": "preloaded/ententen13_tt2_1"
							}
						}
					}
				}
			},
			"11_freqml": {
				"type": "object",
				"properties": {
					"fcrit": {
						"type": "string",
						"example": "fcrit=word%2Fe+-1%3C0+lemma%2Fe+-1%3C0"
					},
					"FCrit": {
						"type": "array",
						"items": {
							"type": "object",
							"properties": {
								"fcrit": {
									"type": "string",
									"example": "word/e -1<0 lemma/e -1<0"
								}
							}
						}
					},
					"Blocks": {
						"type": "array",
						"items": {
							"type": "object",
							"properties": {
								"Head": {
									"type": "array",
									"items": {
										"type": "object",
										"properties": {
											"n": {
												"type": "string",
												"example": "word"
											},
											"s": {
												"type": "integer",
												"example": 0
											},
											"id": {
												"type": "string",
												"example": "word/e"
											}
										}
									}
								},
								"total": {
									"type": "integer",
									"example": 1700
								},
								"totalfrq": {
									"type": "integer",
									"example": 12087
								},
								"Items": {
									"type": "array",
									"items": {
										"type": "object",
										"properties": {
											"Word": {
												"type": "array",
												"items": {
													"type": "object",
													"properties": {
														"n": {
															"type": "string",
															"example": "the"
														}
													}
												}
											},
											"frq": {
												"type": "integer",
												"example": 2621
											},
											"rel": {
												"type": "integer",
												"example": 0
											},
											"reltt": {
												"type": "integer",
												"example": 0
											},
											"norm": {
												"type": "integer",
												"example": 0
											},
											"fbar": {
												"type": "integer",
												"example": 301
											},
											"relbar": {
												"type": "integer",
												"example": 0
											},
											"freqbar": {
												"type": "integer",
												"example": 0
											},
											"pfilter": {
												"type": "string",
												"example": ";q=p-1%3C0+-1%3C0+0+%5Bword%3D%22the%22%5D;q=p-1%3C0+-1%3C0+0+%5Blemma%3D%22the%22%5D"
											},
											"nfilter": {
												"type": "string"
											},
											"pfilter_list": {
												"type": "array",
												"items": {
													"type": "array",
													"items": {
														"type": "string",
														"example": "p-1<0 -1<0 0 [word=\"the\"]"
													}
												}
											},
											"poc": {
												"type": "integer",
												"example": 21.684454372466284
											},
											"fpm": {
												"type": "integer",
												"example": 23.329771292938062
											}
										}
									}
								}
							}
						}
					},
					"paging": {
						"type": "integer",
						"example": 1
					},
					"concsize": {
						"type": "integer",
						"example": 12087
					},
					"fullsize": {
						"type": "integer",
						"example": 14297
					},
					"Desc": {
						"type": "array",
						"items": {
							"type": "object",
							"properties": {
								"op": {
									"type": "string",
									"example": "Query"
								},
								"arg": {
									"type": "string",
									"example": "[lc=\"dog\" | lemma_lc=\"dog\"]"
								},
								"nicearg": {
									"type": "string",
									"example": "dog"
								},
								"rel": {
									"type": "integer",
									"example": 107.59
								},
								"size": {
									"type": "integer",
									"example": 12087
								},
								"tourl": {
									"type": "string",
									"example": "q=q%5Blc%3D%22dog%22+%7C+lemma_lc%3D%22dog%22%5D"
								}
							}
						}
					},
					"numofcolls": {
						"type": "integer",
						"example": 0
					},
					"hitlen": {
						"type": "integer",
						"example": 1
					},
					"wllimit": {
						"type": "integer",
						"example": 1000
					},
					"lastpage": {
						"type": "integer",
						"example": 0
					},
					"ml": {
						"type": "boolean",
						"example": true
					},
					"api_version": {
						"type": "string",
						"example": "5.63.12"
					},
					"manatee_version": {
						"type": "string",
						"example": "2.36.7-SkE-2.223.6"
					},
					"request": {
						"description": "Just summary section of parsed query parameters used in this endpoint call. These parameters are all documented in the beggining of every endpoint box.",
						"type": "object",
						"properties": {
							"concordance_query": {
								"type": "array",
								"items": {
									"type": "object",
									"properties": {
										"queryselector": {
											"type": "string",
											"example": "iqueryrow"
										},
										"iquery": {
											"type": "string",
											"example": "dog"
										}
									}
								}
							},
							"format": {
								"type": "string",
								"example": "json"
							},
							"fpage": {
								"type": "string",
								"example": "1"
							},
							"showpoc": {
								"type": "string",
								"example": "1"
							},
							"freqlevel": {
								"type": "string",
								"example": "2"
							},
							"group": {
								"type": "string",
								"example": "1"
							},
							"freq_sort": {
								"type": "string",
								"example": "freq"
							},
							"ml1ctx": {
								"type": "string",
								"example": "-1<0"
							},
							"showreltt": {
								"type": "string",
								"example": "1"
							},
							"ml2attr": {
								"type": "string",
								"example": "lemma"
							},
							"ml1attr": {
								"type": "string",
								"example": "word"
							},
							"ml2ctx": {
								"type": "string",
								"example": "-1<0"
							},
							"fmaxitems": {
								"type": "string",
								"example": "5000"
							},
							"corpname": {
								"type": "string",
								"example": "preloaded/bnc2_tt21"
							},
							"showrel": {
								"type": "string",
								"example": "1"
							}
						}
					}
				}
			}
		}
	},
	"security": [
		{ "basicAuth": []}
	]
}
